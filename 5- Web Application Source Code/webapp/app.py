from flask import Flask, render_template, request
import pandas as pd
import os
from src.modules import (
    create_engine_load_data,
    setup_nmf,
    process_user_input,
    recommend_movies,
    youtubeAPIkey,
    get_yt_videos
)

YOUTUBE_API_KEY = os.getenv('YOUTUBE_API_KEY')

engine, all_ratings = create_engine_load_data()
NMF_Model, genre_movie_matrix, user_movie_id_ratings_matrix = setup_nmf(
all_ratings=all_ratings,
engine=engine,
number_of_genres = 10
)


app = Flask(__name__)

@app.route('/')
def home():
    return render_template('index.html')

@app.route('/o1')
def o1():
    return render_template('o1.html')

@app.route('/select')
def select():
    user_input = request.args.items()

    guesses_list = []
    for ui in user_input:
        if ui[1]:
            guesses = process_user_input(user_input=ui, all_ratings=all_ratings)
            guesses_list.append(guesses)

    return render_template(
        'select.html',
        guesses_list=guesses_list,
        user_input=user_input
    )

@app.route('/recommend')
def recommend():
    user_movie_title_list = request.args.values()
    recom_movie_titles = recommend_movies(
        all_ratings=all_ratings,
        user_movie_title_list=user_movie_title_list,
        user_movie_id_ratings_matrix=user_movie_id_ratings_matrix,
        genre_movie_matrix=genre_movie_matrix,
        NMF_Model=NMF_Model,
        engine=engine,
        number_of_recommendations=3
    )

    yt_results = ""
    if YOUTUBE_API_KEY:
        youtube = youtubeAPIkey(YOUTUBE_API_KEY)
        yt_results = get_yt_videos(youtube, titles=recom_movie_titles)
    else:
        yt_results = []
        for r in recom_movie_titles:
            dict = {}
            dict['recommendation'] = r
            yt_results.append(dict)

    return render_template(
        'recommend.html',
        yt_results=yt_results
    )

@app.route('/o3')   
def o3():
    df = pd.read_csv("DropDownList.csv")
    return render_template('o3.html', table=df)

@app.route('/o3b')
def o3b():
    recomm = request.args.get('table')
    engage = float(request.args.get('engage'))
    satisfy = float(request.args.get('satisfy'))
    # -*- coding: utf-8 -*-
    """PoornaWebApp.ipynb

    Automatically generated by Colaboratory.

    Original file is located at
        https://colab.research.google.com/drive/1x4-k1L82MaoBfftHNwAvEvpQs5f9FrLL
    """


    import tensorflow as tf
    from tensorflow.keras import backend as K
    from tensorflow.keras import activations, initializers, regularizers, constraints
    from tensorflow.keras.layers import Layer, InputSpec
    import pandas as pd
    import json
    import numpy as np
    from keras.models import load_model
    from tensorflow.keras.optimizers import Adam
    from tensorflow.keras.initializers import VarianceScaling
    from tensorflow.keras.layers import Input, Dense,Concatenate,ReLU,Dropout
    from tensorflow.keras.models import Model
    from tensorflow.keras.callbacks import Callback
    from sklearn.metrics import roc_auc_score,explained_variance_score
    from sklearn.model_selection import train_test_split
    from sklearn.preprocessing import MinMaxScaler
    from transformers import BertTokenizer, TFBertModel
    from scipy.special import expit
    import random
    # Fix random seed for reproducibility
    SEED = 1
    np.random.seed(SEED)
    random.seed(SEED)

    import pandas as pd
    import numpy as np
    from sklearn.feature_extraction.text import CountVectorizer
    from sklearn.metrics.pairwise import cosine_similarity

    # read our original dataset
    df = pd.read_csv('videos.csv')

    # helper function to het index from the dataset based on the title(our query)
    def get_index_from_title(title):
        return df[df.title == title]["index"].values[0]

    cv = CountVectorizer()
    count_matrix = cv.fit_transform(df["tags"])
    cosine_sim = cosine_similarity(count_matrix)
    df['index'] = range(0, len(df) )

    """Our QUERY. This is video title from your dropdown.
    I selected this title:"iPhone X + iPhone 8 Hands on!". But in web app it should be dynamic
    """

    query = recomm
    movie_index = get_index_from_title(query)
    print('Query = ', movie_index, query)

    """Content based similarity(cosine similarity) based on 'tags' column for a given query(title from the dropdown)"""

    # get similar movies
    similar_movies = list(enumerate(cosine_sim[movie_index]))
    sorted_similar_movies = sorted(similar_movies, key=lambda x:x[1], reverse=True)

    # return top 50 as our candidate list
    sorted_similar = sorted_similar_movies[1:51]
    movie_indices = [i[0] for i in sorted_similar]
    candidate_df = df.iloc[movie_indices]
    candidate_df.head()

    """Save if you want, but not necessary. If it will be easier for you to load later for prediction. """

    #candidate_list.to_csv('CandidateList.csv')

    """I want to show this 50 videos (candidate list) on the web page once user selected video(title) from you fropdown. To show that we first created this candidate list based on the query.

    **2. Prediction(using MMOE)**. Actual program for ranking  our candidate list and selecting top 5 from it

    Just Copy this. This is MMOE class from the paper. you will need it to create a model
    """

    class MMoE(Layer):
        """
        Multi-gate Mixture-of-Experts model.
        """

        def __init__(self,
                    units,
                    num_experts,
                    num_tasks,
                    use_expert_bias=True,
                    use_gate_bias=True,
                    expert_activation='relu',
                    gate_activation='softmax',
                    expert_bias_initializer='zeros',
                    gate_bias_initializer='zeros',
                    expert_bias_regularizer=None,
                    gate_bias_regularizer=None,
                    expert_bias_constraint=None,
                    gate_bias_constraint=None,
                    expert_kernel_initializer='VarianceScaling',
                    gate_kernel_initializer='VarianceScaling',
                    expert_kernel_regularizer=None,
                    gate_kernel_regularizer=None,
                    expert_kernel_constraint=None,
                    gate_kernel_constraint=None,
                    activity_regularizer=None,
                    **kwargs):
            """
            Method for instantiating MMoE layer.
            :param units: Number of hidden units
            :param num_experts: Number of experts
            :param num_tasks: Number of tasks
            :param use_expert_bias: Boolean to indicate the usage of bias in the expert weights
            :param use_gate_bias: Boolean to indicate the usage of bias in the gate weights
            :param expert_activation: Activation function of the expert weights
            :param gate_activation: Activation function of the gate weights
            :param expert_bias_initializer: Initializer for the expert bias
            :param gate_bias_initializer: Initializer for the gate bias
            :param expert_bias_regularizer: Regularizer for the expert bias
            :param gate_bias_regularizer: Regularizer for the gate bias
            :param expert_bias_constraint: Constraint for the expert bias
            :param gate_bias_constraint: Constraint for the gate bias
            :param expert_kernel_initializer: Initializer for the expert weights
            :param gate_kernel_initializer: Initializer for the gate weights
            :param expert_kernel_regularizer: Regularizer for the expert weights
            :param gate_kernel_regularizer: Regularizer for the gate weights
            :param expert_kernel_constraint: Constraint for the expert weights
            :param gate_kernel_constraint: Constraint for the gate weights
            :param activity_regularizer: Regularizer for the activity
            :param kwargs: Additional keyword arguments for the Layer class
            """
            # Hidden nodes parameter
            self.units = units
            self.num_experts = num_experts
            self.num_tasks = num_tasks

            # Weight parameter
            self.expert_kernels = None
            self.gate_kernels = None
            self.expert_kernel_initializer = initializers.get(expert_kernel_initializer)
            self.gate_kernel_initializer = initializers.get(gate_kernel_initializer)
            self.expert_kernel_regularizer = regularizers.get(expert_kernel_regularizer)
            self.gate_kernel_regularizer = regularizers.get(gate_kernel_regularizer)
            self.expert_kernel_constraint = constraints.get(expert_kernel_constraint)
            self.gate_kernel_constraint = constraints.get(gate_kernel_constraint)

            # Activation parameter
            self.expert_activation = activations.get(expert_activation)
            self.gate_activation = activations.get(gate_activation)

            # Bias parameter
            self.expert_bias = None
            self.gate_bias = None
            self.use_expert_bias = use_expert_bias
            self.use_gate_bias = use_gate_bias
            self.expert_bias_initializer = initializers.get(expert_bias_initializer)
            self.gate_bias_initializer = initializers.get(gate_bias_initializer)
            self.expert_bias_regularizer = regularizers.get(expert_bias_regularizer)
            self.gate_bias_regularizer = regularizers.get(gate_bias_regularizer)
            self.expert_bias_constraint = constraints.get(expert_bias_constraint)
            self.gate_bias_constraint = constraints.get(gate_bias_constraint)

            # Activity parameter
            self.activity_regularizer = regularizers.get(activity_regularizer)

            # Keras parameter
            self.input_spec = InputSpec(min_ndim=2)
            self.supports_masking = True

            super(MMoE, self).__init__(**kwargs)

        def build(self, input_shape):
            """
            Method for creating the layer weights.
            :param input_shape: Keras tensor (future input to layer)
                                or list/tuple of Keras tensors to reference
                                for weight shape computations
            """
            assert input_shape is not None and len(input_shape) >= 2

            input_dimension = input_shape[-1]

            # Initialize expert weights (number of input features * number of units per expert * number of experts)
            self.expert_kernels = self.add_weight(
                name='expert_kernel',
                shape=(input_dimension, self.units, self.num_experts),
                initializer=self.expert_kernel_initializer,
                regularizer=self.expert_kernel_regularizer,
                constraint=self.expert_kernel_constraint,
            )

            # Initialize expert bias (number of units per expert * number of experts)
            if self.use_expert_bias:
                self.expert_bias = self.add_weight(
                    name='expert_bias',
                    shape=(self.units, self.num_experts),
                    initializer=self.expert_bias_initializer,
                    regularizer=self.expert_bias_regularizer,
                    constraint=self.expert_bias_constraint,
                )

            # Initialize gate weights (number of input features * number of experts * number of tasks)
            self.gate_kernels = [self.add_weight(
                name='gate_kernel_task_{}'.format(i),
                shape=(input_dimension, self.num_experts),
                initializer=self.gate_kernel_initializer,
                regularizer=self.gate_kernel_regularizer,
                constraint=self.gate_kernel_constraint
            ) for i in range(self.num_tasks)]

            # Initialize gate bias (number of experts * number of tasks)
            if self.use_gate_bias:
                self.gate_bias = [self.add_weight(
                    name='gate_bias_task_{}'.format(i),
                    shape=(self.num_experts,),
                    initializer=self.gate_bias_initializer,
                    regularizer=self.gate_bias_regularizer,
                    constraint=self.gate_bias_constraint
                ) for i in range(self.num_tasks)]

            self.input_spec = InputSpec(min_ndim=2, axes={-1: input_dimension})

            super(MMoE, self).build(input_shape)

        def call(self, inputs, **kwargs):
            """
            Method for the forward function of the layer.
            :param inputs: Input tensor
            :param kwargs: Additional keyword arguments for the base method
            :return: A tensor
            """
            gate_outputs = []
            final_outputs = []

            # add a shared bottom layer (relu layer)

            # f_{i}(x) = activation(W_{i} * x + b), where activation is ReLU according to the paper
            # expert_outputs = K.tf.tensordot(a=inputs, b=self.expert_kernels, axes=1)
            expert_outputs = tf.tensordot(a=inputs, b=self.expert_kernels, axes=1)
            # Add the bias term to the expert weights if necessary
            if self.use_expert_bias:
                expert_outputs = K.bias_add(x=expert_outputs, bias=self.expert_bias)
            expert_outputs = self.expert_activation(expert_outputs)

            # g^{k}(x) = activation(W_{gk} * x + b), where activation is softmax according to the paper
            for index, gate_kernel in enumerate(self.gate_kernels):
                gate_output = K.dot(x=inputs, y=gate_kernel)
                # Add the bias term to the gate weights if necessary
                if self.use_gate_bias:
                    gate_output = K.bias_add(x=gate_output, bias=self.gate_bias[index])
                gate_output = self.gate_activation(gate_output)
                gate_outputs.append(gate_output)

            # f^{k}(x) = sum_{i=1}^{n}(g^{k}(x)_{i} * f_{i}(x))
            for gate_output in gate_outputs:
                expanded_gate_output = K.expand_dims(gate_output, axis=1)
                weighted_expert_output = expert_outputs * K.repeat_elements(expanded_gate_output, self.units, axis=1)
                final_outputs.append(K.sum(weighted_expert_output, axis=2))

            return final_outputs

        def compute_output_shape(self, input_shape):
            """
            Method for computing the output shape of the MMoE layer.
            :param input_shape: Shape tuple (tuple of integers)
            :return: List of input shape tuple where the size of the list is equal to the number of tasks
            """
            assert input_shape is not None and len(input_shape) >= 2

            output_shape = list(input_shape)
            output_shape[-1] = self.units
            output_shape = tuple(output_shape)

            return [output_shape for _ in range(self.num_tasks)]

        def get_config(self):
            """
            Method for returning the configuration of the MMoE layer.
            :return: Config dictionary
            """
            config = {
                'units': self.units,
                'num_experts': self.num_experts,
                'num_tasks': self.num_tasks,
                'use_expert_bias': self.use_expert_bias,
                'use_gate_bias': self.use_gate_bias,
                'expert_activation': activations.serialize(self.expert_activation),
                'gate_activation': activations.serialize(self.gate_activation),
                'expert_bias_initializer': initializers.serialize(self.expert_bias_initializer),
                'gate_bias_initializer': initializers.serialize(self.gate_bias_initializer),
                'expert_bias_regularizer': regularizers.serialize(self.expert_bias_regularizer),
                'gate_bias_regularizer': regularizers.serialize(self.gate_bias_regularizer),
                'expert_bias_constraint': constraints.serialize(self.expert_bias_constraint),
                'gate_bias_constraint': constraints.serialize(self.gate_bias_constraint),
                'expert_kernel_initializer': initializers.serialize(self.expert_kernel_initializer),
                'gate_kernel_initializer': initializers.serialize(self.gate_kernel_initializer),
                'expert_kernel_regularizer': regularizers.serialize(self.expert_kernel_regularizer),
                'gate_kernel_regularizer': regularizers.serialize(self.gate_kernel_regularizer),
                'expert_kernel_constraint': constraints.serialize(self.expert_kernel_constraint),
                'gate_kernel_constraint': constraints.serialize(self.gate_kernel_constraint),
                'activity_regularizer': regularizers.serialize(self.activity_regularizer)
            }
            base_config = super(MMoE, self).get_config()

            return dict(list(base_config.items()) + list(config.items()))

    def build_model():
        # Set up the input layer
        input_video_emb = Input(shape=(768,))
        input_likes = Input(shape=(1,))
        input_dislikes = Input(shape=(1,))
        input_comments = Input(shape=(1,))
        input_user_emb = Input(shape=(768,))
        input_views = Input(shape=(1,))
        #input = Concatenate()([input_video_emb,input_user_emb,input_other_features])
        input = Concatenate()([input_video_emb,input_user_emb,input_likes,input_dislikes,input_comments,input_views])
        
        input_layer = ReLU()(input)

        # add the shared ReLu layer
        # Set up MMoE layer
        mmoe_layers = MMoE(
            units=4,
            num_experts=8,
            num_tasks=4
        )(input_layer)

        output_layers = []
        print("Output is user_click, user_rating, user_like and time_spend...")
        output_info = [(1, 'user_click'),(1,'user_rating'),(1,'user_like'),(1,'time_spend')]  # the rating is categorical or regression?
        output_activation = ['softmax','linear','softmax','linear'] # None (linear) activation for regression task; softmax for classification

        # Build tower layer from MMoE layer
        for index, task_layer in enumerate(mmoe_layers):
            tower_layer = Dense(
                units=8,
                activation='relu',
                kernel_initializer=VarianceScaling())(task_layer)
            output_layer = Dense(
                units=output_info[index][0],
                name=output_info[index][1],
                activation=output_activation[index],
                kernel_initializer=VarianceScaling())(tower_layer)
            output_layers.append(output_layer)

        # Compile model
        # model = Model(inputs=[input_video_tags,input_video_title,input_video_desp,input_video_view], outputs=output_layers)
        model = Model(inputs=[input_video_emb,input_user_emb,input_likes,input_dislikes,input_comments,input_views], outputs=output_layers)
        return model

    """Helper function to calculate final score(rank) for each video in the Candidate List. Our prediction"""

    def final_score(weights_for_engagement, weights_for_satification, main_model, position_biase_model,test_main,test_position):

        print("the manually set weights for user engagement is", str(weights_for_engagement))
        print("the manually set weights for user satisfaction is", str(weights_for_satification))

        preds = main_model.predict(test_main)
        user_click = preds[0]
        user_rating = preds[1]
        user_like = preds[2]
        time_spend = preds[3]

        preds_position = position_biase_model.predict(test_position)
        return weights_for_engagement*expit(user_click+time_spend+preds_position) + weights_for_satification*expit(user_rating+user_like)

    """Some data preparation: embedding. For some reason the same embedded columns are not working(some errors), so need to do embedding again. Maybe we can fix tomorrow, it will be faster then."""

    # # data preparation before prediction for Candidate List here (top 50 videos) 
    candidate_df['video_emb'] = candidate_df['title']

    tokenizer = BertTokenizer.from_pretrained('bert-base-cased')
    model = TFBertModel.from_pretrained('bert-base-cased')
    max_length = 10 # change it to your computer capacity
    batch_encoding = tokenizer.batch_encode_plus(candidate_df['video_emb'].tolist(), max_length=max_length, pad_to_max_length=True)

    outputs = model(tf.convert_to_tensor(batch_encoding['input_ids'])) # shape: (batch,sequence length, hidden state)
    embeddings_video = tf.reduce_mean(outputs[0],1)
    candidate_df['video_emb'] = embeddings_video.numpy().tolist()

    # assuming tags as user interested tags
    batch_encoding_user = tokenizer.batch_encode_plus(candidate_df['tags'].tolist(), max_length=max_length, pad_to_max_length=True)
    outputs_user = model(tf.convert_to_tensor(batch_encoding_user['input_ids'])) # shape: (batch,sequence length, hidden state)
    embeddings_user = tf.reduce_mean(outputs_user[0],1)
    candidate_df['user_emb'] = embeddings_user.numpy().tolist()


    # also min max scaling
    scaler = MinMaxScaler()
    candidate_df[['views', 'likes', 'dislikes','comment_total']] = scaler.fit_transform(candidate_df[['views', 'likes', 'dislikes','comment_total']])

    """Actual prediction of the final scores"""

    test_main = [np.asarray(np.squeeze(candidate_df[['video_emb']].values.tolist())).astype(np.float32),
            np.asarray(np.squeeze(candidate_df[['user_emb']].values.tolist())).astype(np.float32),
            candidate_df[['likes']].values,
            candidate_df[['dislikes']].values,
            candidate_df[['comment_total']].values,
            candidate_df[['views']].values]

    position = pd.get_dummies(candidate_df, columns=['device_info'], prefix='', prefix_sep='')[['android', 'ios', 'web','position']]

    #load saved models
    position_biase = load_model('biase.hdf5')
    mmoe = build_model()
    mmoe.load_weights('mmoe.hdf5')
    adam_optimizer = Adam()
    mmoe.compile(
            loss={'user_click': 'binary_crossentropy', 'user_rating':'MSE','user_like': 'binary_crossentropy','time_spend':'MSE'},
            optimizer=adam_optimizer,
            metrics=['accuracy'])
    final_score_list = final_score(engage/10, satisfy/10, mmoe, position_biase,test_main,position)

    # print("Final score = ", final_score_list)

    # merging results from model.predict() with candidate list
    candidate_df['final_score'] = final_score_list

    #sort by final_score desc, we want to take highest scores
    final_set = candidate_df.sort_values(by='final_score', ascending=False)

    """select top 5 to show on web app as a final top5 recommended videos"""

    top_five = final_set[['title','final_score', 'tags']][0:5]
    
    # save if you want top 5 to csv file
    # top_five.to_csv('TopFive.csv')

    # just checking
    print(candidate_df.head(50))
    print('------------------')
    print(top_five.head())
    return render_template("o3results.html", query=query,candidate_df=candidate_df[["title","user_rating", "user_like", "user_click","time_spend"]], top_five=top_five[["title","final_score"]])


if __name__ == '__main__':
    app.run(port=5000, debug=True)
